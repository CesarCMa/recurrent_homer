"""`TextVectorizer' implementation module. """

import pickle

import tensorflow as tf
from pathlib import Path
import numpy as np

class TextVectorizer:
    """Text vectorization class that converts text into vectors if numeric
    ids based on a vocabulary, and vice-versa. Vocabulary is generated
    based on text corpus provided when initializing the class.
    """

    test_sequence: list = ["a", "f", "r", "i", "y"]

    def __init__(self, text_corpus: str = None, vocabulary_path: Path = None):
        self._saved_test_ids = None

        if text_corpus:
            self.vocabulary = sorted(set(text_corpus))
        elif vocabulary_path:
            self.load_vocab_from_path(vocabulary_path)
        else:
            raise ValueError("Please provide text corpus or vocabulary path.")

        self.ids_from_chars = tf.keras.layers.StringLookup(
            vocabulary=list(self.vocabulary), mask_token=None
        )
        self.chars_from_ids = tf.keras.layers.StringLookup(
            vocabulary=self.ids_from_chars.get_vocabulary(),
            invert=True,
            mask_token=None,
        )

        if isinstance(self._saved_test_ids, (np.ndarray, np.generic)):
            self._check_correct_vocab()

    def convert_text_to_id(self, text: list[str]) -> tf.RaggedTensor:
        """Convert provided test into a tensor of ids, each of them
        representing a token form the vocabulary.
        """
        token_tensor = self._unicode_split(text)
        return self.ids_from_chars(token_tensor)

    def _unicode_split(self, text: list[str]) -> tf.RaggedTensor:
        """Split input text into tokens"""
        return tf.strings.unicode_split(text, input_encoding="UTF-8")

    def convert_id_to_text(self, id_tensor: tf.RaggedTensor) -> np.array:
        """Convert tensor with ids regerated with `TextVectorizer` into
        an array of strings
        """
        characters = self.chars_from_ids(id_tensor)
        return tf.strings.reduce_join(characters, axis=-1).numpy()

    def save_vocabulary(self, data_path: Path):
        """Save vocabulary of the vectorizer to pickle, together with
        the test string and the expected output for the text string.
        """
        with open(data_path / "vocabulary.pkl", "wb") as file:
            pickle.dump(
                {
                    "vocabulary": self.vocabulary,
                    "expected_test_ids": self._test_conversor(),
                },
                file,
            )

    def load_vocab_from_path(self, vocabulary_path: Path) -> None:
        """Load vocabulary from path provided."""
        with open(vocabulary_path, "rb") as file:
            saved_vocab = pickle.load(file)
        self.vocabulary = saved_vocab["vocabulary"]
        self._saved_test_ids = saved_vocab["expected_test_ids"]

    def _test_conversor(self):
        """Test the ids generated by the conversor with the fixed
        set of characters: `TextVectorizer.test_sequence`.
        """
        return self.ids_from_chars(tf.constant(self.test_sequence)).numpy()

    def _check_correct_vocab(self):
        if set(self._test_conversor()) == set(self._saved_test_ids):
            print("Vocabulary correctly loaded! üëçÔ∏è")
        else:
            raise ValueError("Error loading vocabulary, test ids do not match.")
